<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Posts</a>
            </nav>
        </header>

        <main role="main">
            <article>
    <section class="header">
        Posted on February 25, 2025
        
    </section>
    <section>
        <h1>Algebra For Cryptography I</h1>
        <p>My friend <a href="https://github.com/pittma">Dan</a> texted me a question about the Advanced Encryption Standard (<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>)
algorithm: he was writing a reference implementation in Haskell to check his understanding
of the implementation in—highly optimized—assembler that he was working with.
I know nothing about cryptography, but was game to look at his implementation.
Something that immediately jumped out was <a href="https://github.com/pittma/crypto-ref/blob/0cabf4d9c62af993a598616a0e928b23b255044e/src/AES/Shared.hs#L10-L14">an integer value named “irrPolynomial”</a>
which I took to mean “irreducible polynomial.” This piqued my interest.
I spent a few days taking peeks at the Handbook of Applied Cryptography—and
my grad school Abstract Algebra textbook to shake out the cobwebs—
and thought about this while I was walking the dog or doing dishes.
I then blasted Dan with an extremely long text thread explaining what
was going on mathematically and the sequence of steps that got me to that understanding.
This post is that text thread, very lightly edited.</p>
<p>I’ll just add a couple things up front.
First, I am not an expert and I could easily have made mistakes here!
Nonetheless, I hope that seeing my reasoning is illuminating.
Second, if you are not comfortable with equivalence relations and quotient constructions,
that’s okay! These are advanced undergraduate ideas that most students to not encounter
in their full generality. They are, however, totally ubiquitous in mathematics
and it is extremely worthwhile to bite the bullet and get comfortable with them.
I have a previous blog post about them, but feel free to go directly to the source:
the basic idea is covered in the eleven-and-a-half page “Preliminaries” chapter
of <a href="https://www.wiley.com/en-us/Abstract+Algebra%2C+3rd+Edition-p-9780471433347">Dummit and Foote</a>. It is worth reading.
(It covers a bunch of things, it does not use all of that space on this one idea.)
If you would like to find a copy of the book, I would definitely not search on
the internet for the title of the book and “pdf”. Why waste your time?</p>
<h1 id="why">Why?</h1>
<p>The point of all of this is to answer the question: what do <span class="math inline"><em>n</em></span>-bit binary integers
have to do with polynomials and why is relating those things to each other at all useful?
Read on to find out!</p>
<h1 id="rings-and-ideals">Rings and Ideals</h1>
<p>If <span class="math inline"><em>R</em></span> is a commutative ring, a subset <span class="math inline"><em>I</em></span> of <span class="math inline"><em>R</em></span> is an <a href="https://en.wikipedia.org/wiki/Ideal_(ring_theory)"><em>ideal</em></a> if it is</p>
<ul>
<li>closed under addition and multiplication</li>
<li>has the “absorption” property: anything in <span class="math inline"><em>R</em></span> times anything in <span class="math inline"><em>I</em></span> lands back in <span class="math inline"><em>I</em></span>.</li>
</ul>
<p>The ideal generated by a subset <span class="math inline"><em>S</em> ⊆ <em>R</em></span> is the set of all sums of eleemnts of <span class="math inline"><em>S</em></span>
multiplied by elements of <span class="math inline"><em>R</em></span>.
A very nice kind of ideal is an ideal generated by a set with one element:
if <span class="math inline"><em>S</em> = {<em>s</em>}</span>, this ideal is written simply as <span class="math inline">(<em>s</em>)</span>.
An ideal generated by a single element is called a <a href="https://en.wikipedia.org/wiki/Principal_ideal"><em>principal</em> ideal</a>.</p>
<p>Ideals are the subsets of rings we can “mod out” by, that is, out of which we can form quotient rings:
if <span class="math inline"><em>I</em></span> is an ideal, we consider elements of <span class="math inline"><em>R</em></span> to be equivalent if their difference is in <span class="math inline"><em>I</em></span>,
then define addition and multiplication on the set <span class="math inline"><em>R</em>/<em>I</em></span> of equivalence classes in terms
of the corresponding operations on <span class="math inline"><em>R</em></span>. Ideals have nice properties that make this work.</p>
<h1 id="modular-arithmetic">Modular arithmetic</h1>
<p>The integers are a ring <span class="math inline">ℤ</span>, the set of all multiples of <span class="math inline"><em>n</em></span> is an ideal <span class="math inline">(<em>n</em>)</span>,
and the integers mod <span class="math inline"><em>n</em></span> is the quotient ring <span class="math inline">ℤ/(<em>n</em>)</span>.
We usually write this using group and subgroup notation <span class="math inline">ℤ/<em>n</em>ℤ</span> rather than ring
and ideal notation, but that is what it is.</p>
<h1 id="fields">Fields</h1>
<p>A <a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a> is basically a ring in which every element has an additive
inverse and every non-zero element has a multiplicative inverse.
So we can add, multiply, subtract, and divide.
Fields can be finite or infinite.
If <span class="math inline"><em>p</em></span> is a prime, then <span class="math inline">ℤ/<em>p</em>ℤ</span> is a field. <span class="math inline">ℤ/<em>p</em><sup><em>n</em></sup>ℤ</span>, however, is not a field:
in this ring, it is possible to multiply together two non-zero numbers,
e.g. <span class="math inline"><em>p</em></span> and <span class="math inline"><em>p</em><sup><em>n</em> − 1</sup></span>, and get zero.
It <a href="https://en.wikipedia.org/wiki/Field_(mathematics)#Consequences_of_the_definition">follows from the definition of a field</a> that, in a field,
this never happens. (Fields are <a href="https://en.wikipedia.org/wiki/Integral_domain"><em>integral domains</em></a>.)</p>
<h1 id="questions">Questions</h1>
<p>We can ask two related questions</p>
<ol type="1">
<li>If we have <span class="math inline"><em>n</em></span>-bit binary integers, sure they form a ring, but can we make them into a field?</li>
<li>If we know that <span class="math inline">ℤ/<em>p</em>ℤ</span> is a field, but that <span class="math inline">ℤ/<em>p</em><sup><em>n</em></sup>ℤ</span> is not, is there a way
to make more fields by, like, making <span class="math inline"><em>n</em></span>-tuples of field elements into a field?</li>
</ol>
<p>These are related because we can think of <span class="math inline"><em>n</em></span>-bit binary integers as <span class="math inline"><em>n</em></span>-tuples of
binary digits, that is, of elements of the field <span class="math inline">ℤ/2ℤ</span>.
If we want to do the first thing—make those <span class="math inline"><em>n</em></span>-tuples into a field—maybe there is some
general construction—a way to do the second thing—that will help us out.</p>
<p>The answer is: there is a way to make <span class="math inline"><em>n</em></span>-tuples of field elements into a field,
but in a not-at-all obvious way.</p>
<h1 id="first-attempt">First attempt</h1>
<p>Let’s just write <span class="math inline">𝔽</span> for our field for the moment and think about what we can do
with <span class="math inline">𝔽<sup><em>n</em></sup></span>, the set of n-tuples of elements of <span class="math inline">𝔽</span>.
We can obviously add and multiply them component-wise.
We would like <span class="math inline">(0,…,0)</span> to be the zero element, the additive identity,
of our field and <span class="math inline">(1,…,1)</span> to the be the multiplicative identity.
The problem though is: say <span class="math inline"><em>n</em> = 3</span>, we could have <span class="math inline">(1,0,1)</span> and <span class="math inline">(0,1,0)</span>,
neither of those is <span class="math inline">(0,0,0)</span>, but, if we multiply them together component-wise,
we get <span class="math inline">(0,0,0)</span>.
And we know you can’t do that in a field. So this won’t quite work.</p>
<p>We did manage to make <span class="math inline">𝔽<sup><em>n</em></sup></span> into a ring, though, just not a field.
What if we forget a little bit of structure and just consider <span class="math inline">𝔽<sup><em>n</em></sup></span> as a vector space
so we can add elements and scale them, i.e. multiply them by elements of <span class="math inline">𝔽</span>
—<span class="math inline"><em>c</em>(<em>f</em><sub>1</sub>,…,<em>f</em><sub><em>n</em></sub>) = (<em>c</em><em>f</em><sub>1</sub>,…,<em>c</em><em>f</em><sub><em>n</em></sub>)</span> for <span class="math inline"><em>c</em></span> in <span class="math inline">𝔽</span>—but we cannot multiply two
<span class="math inline"><em>n</em></span>-tuples together.</p>
<p>Does that help?
Maybe! If there is some other way to construct this vector space and we can figure out
how to turn <em>that</em> vector space into a field, then we can turn this thing into a field.
(This will use a standaard trick that we’ll get to after we do it.)</p>
<h1 id="second-attempt">Second attempt</h1>
<p>Here is another way to make <span class="math inline">𝔽<sup><em>n</em></sup></span> as a vector space:
take the ring of polymomials with coefficients in <span class="math inline">𝔽</span> in a single variable,
this is denoted <span class="math inline">𝔽[<em>x</em>]</span>,
form the principal ideal generated by the single polynomial <span class="math inline"><em>x</em><sup><em>n</em></sup></span>,
and take the quotient by that ideal: <span class="math inline">𝔽[<em>x</em>]/(<em>x</em><sup><em>n</em></sup>)</span>.
As a vector space, this has a basis <span class="math inline">1, <em>x</em>, <em>x</em><sup>2</sup>, …, <em>x</em><sup><em>n</em> − 1</sup></span>, that is,
every polynomial in that quotient ring can be written uniquely as
<span class="math inline"><em>a</em><sub>0</sub> + <em>a</em><sub>1</sub><em>x</em> + … + <em>a</em><sub><em>n</em> − 1</sub><em>x</em><sup><em>n</em> − 1</sup></span>
where the <span class="math inline"><em>a</em><sub><em>i</em></sub></span> are in <span class="math inline">𝔽</span>.
This is just like modular arithmetic of integers: the equivalence class of every
integer mod <span class="math inline"><em>n</em></span> has a unique representative between <span class="math inline">0</span> and <span class="math inline"><em>n</em> − 1</span>.</p>
<p>This almost works! But not quite. The problem is that <span class="math inline"><em>x</em><sup><em>n</em></sup></span> is a reducible polynomial:
we can write it as, say, <span class="math inline"><em>x</em>(<em>x</em><sup><em>n</em> − 1</sup>)</span> and that means that we again have nonzero
elements that we can multiply together to get <span class="math inline">0</span> :(.
So, again, this is not a field.
However, if we choose an <em>irreducible</em> polynomial <span class="math inline"><em>f</em>(<em>x</em>)</span>, one that cannot be written
as a product of lower degree polynomials, then this doesn’t happen.
And, in fact—proof / exercise—if we take the quotient of <span class="math inline">𝔽[<em>x</em>]</span> by the ideal
generated by <span class="math inline"><em>f</em>(<em>x</em>)</span>, <span class="math inline">𝔽[<em>x</em>]/(<em>f</em>(<em>x</em>))</span>,
that <em>is</em> a field.
And if we forget the field structure and just think of it as a vector space,
this “<em>is</em>” the vector space <span class="math inline">𝔽<sup><em>n</em></sup></span> we started with!
More specifically: there is a function <span class="math inline"><em>ϕ</em> : 𝔽<sup><em>n</em></sup> → 𝔽[<em>x</em>]/(<em>f</em>(<em>x</em>))</span>,
defined by <span class="math inline"><em>ϕ</em>(<em>a</em><sub>0</sub>,…,<em>a</em><sub><em>n</em> − 1</sub>) = <em>a</em><sub>0</sub> + <em>a</em><sub>1</sub><em>x</em> + …<em>a</em><sub><em>n</em> − 1</sub><em>x</em><sup><em>n</em> − 1</sup></span>,
from the thing we were trying to make into a field to this thing that is a field
and this function—exercise again—is a vector space isomorphism.</p>
<h1 id="success">Success</h1>
<p>So, the punchline is: if we have <span class="math inline"><em>n</em></span>-bit binary integers
<span class="math inline">[<em>b</em><sub><em>n</em> − 1</sub>,….<em>b</em><sub>0</sub>]</span> and we want to make them into a field,
we can take the field <span class="math inline">ℤ/2ℤ</span>—also frequently denoted <span class="math inline">𝔽<sub>2</sub></span>—
find an irreducible polynomial of degree <span class="math inline"><em>n</em></span>,
form the field <span class="math inline">𝔽<sub>2</sub>[<em>x</em>]/(<em>f</em>(<em>x</em>))</span>, of polynomials with coeffcients in <span class="math inline">𝔽<sub>2</sub></span>
(again, just the integers mod 2) by modding out by that irreducible polynomial,
and think of a <span class="math inline"><em>n</em></span>-bit binary integer as a polynomial
i.e. <span class="math inline">[<em>b</em><sub><em>n</em> − 1</sub>….<em>b</em><sub>0</sub>] ↔︎ <em>b</em><sub><em>n</em> − 1</sub><em>x</em><sup><em>n</em> − 1</sup> + … + <em>b</em><sub>1</sub><em>x</em> + <em>b</em><sub>0</sub></span>.
When we do arithmetic in that field, if we want to go back to arrays of bits,
we have to remember to choose the unique polynomial of degree <span class="math inline"> &lt; <em>n</em></span> equivalent to
whatever we have before we can map back to an array of bits.
We do that by adding or subtracting <span class="math inline"><em>f</em>(<em>x</em>)</span> some number of times until we find it
or, equivalently, using the fact that <span class="math inline"><em>f</em>(<em>x</em>)</span> is equivalent to <span class="math inline">0</span> to rewrite it.</p>
<h1 id="the-standard-trick">The Standard Trick</h1>
<p>There is a general trick that if <span class="math inline"><em>S</em></span> is a set and <span class="math inline"><em>C</em></span> is some cool algebraic
thing like a group, ring, vector space, field, whatever,
and we have a bijection of sets <span class="math inline"><em>ϕ</em> : <em>S</em> → <em>C</em></span>,
then we can make <span class="math inline"><em>S</em></span> into a cool algebraic thing by “pulling back” the operations
on <span class="math inline"><em>C</em></span>: to perform operations on a pair, say, of elements of <span class="math inline"><em>S</em></span> we just send them
over to <span class="math inline"><em>C</em></span>, operate there, then send the result back and define that to be how
operations on <span class="math inline"><em>S</em></span> work.
So that is what is happening here: we have some operations on arrays of bits of size <span class="math inline"><em>n</em></span>,
but not all the ones we want. We do, however, have a bijection to this fancy
polynomial ring where multiplication is really nice—it is a field so everything
has a multiplicative inverse—so we can just define a new multiplication on arrays
of bits by sending them over there, multiplying there, and sending the answer back.</p>
<figure>
<img src="images/sorry.jpg" alt="image" /><figcaption aria-hidden="true">image</figcaption>
</figure>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
