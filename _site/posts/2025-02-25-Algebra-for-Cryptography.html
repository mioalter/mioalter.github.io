<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Posts</a>
            </nav>
        </header>

        <main role="main">
            <article>
    <section class="header">
        Posted on February 25, 2025
        
    </section>
    <section>
        <h1>Algebra For Cryptography I</h1>
        <p>Rings and Ideals
If <code>R</code> is a commutative ring, a subset <code>I</code> of <code>R</code> is an ideal that
1. is closed under addition and multiplication
2. ⁠has the absorption property: for all <code>r in R</code> and <code>i in I</code>, <code>ri in R</code> so if you multiply something in <code>I</code> by anything in <code>R</code>, you land back in <code>I</code>.
The ideal generated by a set <code>S</code> is the set of all <code>{r_1 s_1 + … + r_n s_n | r_i in R, s_i in S}</code> so finite sums of things in <code>S</code> times things in <code>R</code>.
A very nice kind of ideal is an ideal generated by a set with one element: if <code>S = {s}</code>, this is usually write simply as <code>(s)</code>. An ideal generated by a single element is called a <em>principal</em> ideal.</p>
<p>Ideals are the things we can quotient a ring by and still get a ring meaning, we can define addition and multiplication on the set of equivalence classes <code>R/I</code> in terms of the operations on <code>R</code> and the properties of an ideal make that actually work.</p>
<p>Integers mod n:
The integers are a ring <code>Z</code>, for any <code>n</code>, the set of all multiples of <code>n</code> is a principal ideal <code>(n)</code>, and the integers mod <code>n</code> is the quotient of the ring <code>Z</code> by the ideal <code>(n)</code>. We usually write <code>Z/nZ</code> using group notation rather than <code>Z/(n)</code> using ring and ideal notation, but that is what it is.</p>
<p>Next: fields. A field is a ring where every element has an additive inverse and every non-zero element has a multiplicative inverse. Fields can be finite or infinite. <code>Z/pZ</code> for <code>p</code> a prime is a field. <code>Z/p^kZ</code> however is not a field: we can multiply <code>p</code> and <code>p^{k-1}</code> say which are both non-zero elements, but their product is <code>0</code> :(.
We can ask two related questions that come from different places
1. if we have n-bit binary integers, sure, they form a ring, but can we make them into a field?
2. ⁠if we know that <code>Z/pZ</code> is a field, could we make more fields by, like making n-tuples of field elements into a field?
These are related because we can think of n-bit binary integers are n-tuples of elements of <code>Z/2Z</code>, or <code>F_2</code>, the field with two elements and, if we want to make that into a field, we might want to appeal to some general construction that works for any field and any <code>n</code>.
The answer is, we can, but in a very not-obvious way.</p>
<p>Let’s just write <code>F</code> for our field for the moment and think about with we can do with <code>F^n</code>, the set of n-tuples of elements of <code>F</code>. We can obviously add and multiply them component-wise. We would kind of want <code>(0,…,0)</code> to be the zero element, the additive identity, of our field and <code>(1,…,1)</code> to the be the multiplicative identity. The problem though is: say n = 3, we could have <code>(1,0,1)</code> and <code>(0,1,0)</code>, neither of those is <code>(0,0,0)</code>, but, if we multiply them together component-wise, we get <code>(0,0,0)</code>. So that won’t work. So we got as far as making a ring, but then ran into trouble. What if we forget a little bit of structure and just consider <code>F^n</code> as a vector space so we can add elements and scale them by elements of <code>F</code> e.g. <code>c(f_1,…,f_n) = (cf_1,…,cf_n)</code> for <code>c in F</code>. Does that help? Well, if we can find some other way to make this vector space, then it might.</p>
<p>Here is another way to make <code>F^n</code> as a vector space: take the ring of polymomials with coefficients in <code>F</code> in a single variable <code>F[x]</code>, form the principal ideal generated by the single polynomial <code>x^n</code> and take the quotient by that: <code>F[x] / (x^n)</code>. Then, as a vector space, that has a basis <code>1, x, x^2, …, x^{n-1}</code>, that is, every polynomial in that quotient ring can be written uniquely as <code>a_0 + a_1 x + … + a_{n-1}x^{n-1}</code> where the <code>a_i</code> are in <code>F</code>. This is just like modular arithmetic of integers: the equivalence class of every integer mod <code>n</code> has a unique representative between <code>0</code> and <code>n-1</code>.</p>
<p>This almost works!
But not quite</p>
<p><code>x^n</code> is a reducible polynomial: we can write it as, say, <code>x * x^{n-1}</code> and that means that we again have nonzero elements that we can multiply together to get <code>0</code> :(. However, if we choose an <em>irreducible</em> polynomial <code>f(x)</code>, one that cannot be written as a product of lower degree polynomials, then this doesn’t happen. An in fact—proof / exercise—if we take the quotient of <code>F[x]</code> by the ideal generated by <code>f(x)</code>, <code>F[x] / (f(x))</code>, that <em>is</em> a field. And if we forget the field structure and just think of it as a vector space, we have a vector space isomorphism between <code>F[x]/(f(x))</code> and the thing we were trying to make into a field <code>F^n</code>.</p>
<p>So, the punchline is: if we have n-bit binary integers <code>[b_{n-1}….b_0]</code> and we want to make them into a field, we can take the field <code>F_2</code>, find an irreducible polynomial of degree <code>n</code>, form the field <code>F_2[x] / (f(x))</code>, of polynomials with coeffcients in <code>F_2</code> (just the integers mod 2) mod that irreducible polynomial, and think of a binary integer as a polynomial i.e. <code>[b_{n-1}….b_0] &lt;-&gt; b_{n-1}x^{n-1} + … + b_1 x + b_0</code>. When we do arithmetic in that field, if we want to go back to arrays of bits, we have to remember to choose the unique polynomial of degree &lt; n equivalent to whatever we have before we can map back to an array of bits. We do that by adding or subtracting <code>f(x)</code> some number of times until we find it.</p>
<p>So, I did not work through the details of your <code>multGF</code>, but I am conceptually sure that that is what that has to do with: do arithemtic in this quotient ring of polynomials, then shfit the result back down to a polynomial of degree &lt; n so that it corresponds to an array of bits.</p>
<p>Sorry, this is very long.</p>
<p>It should probably be a blogpost rather than a text thread</p>
<p>I guess the last thing that I’ll say that I feel like I say a lot, but I may not write down enough is: there is a general trick that if <code>S</code> is a set and <code>C</code> is some cool algebraic thing like a group, ring, vector space, field, whatever, and we have a bijection of sets <code>S -&gt; C</code>, then we can make <code>S</code> into a cool algebraic thing by “pulling back” the operations on <code>C</code>: to perform operations on a pair, say, of elements of <code>S</code>, we just send them over to <code>C</code>, operate there, then send the result back and define that to be how operations on <code>S</code> work. So that is what is happening here: we have some operations in arrays of bits of size n, but not all the ones we want. We do, however, have a bijection to this fancy polynomial ring where multiplication is really nice—it is a field so everything has a multiplicative inverse—so we can just define a new multiplication on arrays of bits by sending them over there, multiplying there, and sending the answer back.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
