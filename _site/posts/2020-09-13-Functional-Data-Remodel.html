<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Altered States</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">ALTERED STATES</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>A Functional Data Remodel</h1>
            <article>
    <section class="header">
        Posted on September 13, 2020
        
    </section>
    <section>
        <h1 id="intro">Intro</h1>
<p>This is a short post about a piece of work that my team did at work to rejigger a data model we inherited. The original design was informed by object-oriented thinking and the design that we ended up with is more functionally flavored. Hopefully this post will make a good case for the clarity and flexibility of the latter.</p>
<h1 id="context">Context</h1>
<p>Very brief context: my team at Spotify is under an umbrella that builds Machine Learning infrastructure, we are currently focued <em>features</em> for ML models. We’ll talk a bit more about features in another post, for our purposes: these are the input data needed to build and use ML models. Features are <em>about</em> things: “user age” is about a user, “user-artist afinity score” is about a user-artist pair. The things that features are <em>about</em> we call <em>entities</em>; this post is about how we model entities.</p>
<p>We use entities to say both what a given set of features is about and how to join different sets of features together. A given set of features can have a singular (user, artist, track, …) or plural (user-artist, user-track,…) thing it is about and each singular thing can have multiple types of id: there are various formats of user id, an artist can be identified by an id or a uri, etc. A feature set about user-artist relationships will have both some kind of user id column and some kind of artist id column. We may want to join in features about just users or just artists, and we’ll have to know what kinds of user and artist ids we have to do those joins.</p>
<h1 id="the-original-data-model">The Original Data Model</h1>
<p>The original data model looked something like this</p>
<pre><code>message Entity {
  String name = 1;
  repeated EntityKeyType entity_key_types = 2;
}

message EntityKeyType {
  String name = 1;
  repeated EntityKey entity_keys = 2;
}

message EntityKey {
  String name = 1;
}</code></pre>
<p>so an <code>Entity</code> can have a name like <code>user</code>, <code>artist</code> or <code>user_artist</code>, the <code>EntityKeyType</code> is the singular thing, <code>user</code>, <code>artist</code>, or the list <code>[user, artist]</code>, respectively, of which the <code>Entity</code> consists, and the <code>EntityKey</code> is the kind of identifier each <code>EntityKeyType</code> has, e.g. <code>user</code> has <code>user_id_hex</code>, <code>user_id_base62</code>, etc. Note that the actual value of the user id, say, is not reprsesented here, we just care about the things, their constituent things, and the kinds of identifiers of those constituent things.</p>
<p>So, an <code>Entity</code> is a list of one or more things; each of those things can have one or more kinds of identifiers. That’s all that is going on. But! Having a hierarchy of things each of which <em>has a</em> list of the next level of thing obscures what the building blocks are and how we are allowed to combine them.</p>
<p>Also, nit: <code>Entity.name</code> is actually just a string representation of the other field which is a list, not an independent piece of information.</p>
<p>Mathy aside: a “has a” relationship just says “there is a function”, but does not tell you anything about it. “An A has a B” just says “there is a function from As to Bs”, but not how much or little about the A is captured by resulting B.</p>
<h1 id="the-new-data-model">The New Data Model</h1>
<p>Our observation was: there are two kinds of building blocks</p>
<ul>
<li>the <em>primitive/singular</em> entities: user, artist, track, podcast, etc.</li>
<li>the kinds of identifiers: id_hex, id_base62, gid, uri, etc.</li>
</ul>
<p>There are two kinds of things we can build with these:</p>
<ul>
<li>we can build compound entities by making sets/lists of distinct primitive entities</li>
<li>we can build primitive entity identifiers by forming <code>(primitive entity, identifer)</code> pairs</li>
</ul>
<p>In types/aspirational pseudo-Scala:</p>
<ul>
<li>we have two union types <code>PrimitiveEntity</code> and <code>Identifier</code></li>
<li><code>Entity = ListOfDistinct[PrimitiveEntity] / Set[PrimitiveEntity]</code></li>
<li><code>PrimitiveEntityIdentifier = (PrimitiveEntity, Identifier)</code></li>
</ul>
<p>Now, an Entity <em>is a</em> list of primitive entities. A PrimitiveEntity has a list of PrimitiveEntityIdentifiers because PrimitiveEntityIdentifiers are explicitly (PrimitiveEntity, Identifier) pairs.</p>
<p>Concretely, for a given primitive entity <code>pe</code>, the list of tuples <code>(pe, _)</code> is the list of primitive entity identifiers corresponding to that primitive entity. Each primitive entity still has a list of primitive entity identifiers, e.g. user has user_id_hex, user_id_base62, but that list doesn’t have to be a field on PrimitiveEntity, we get it by having a couple of types and functions between them.</p>
<p>Mathily: there is a projection function</p>
<pre><code>π: (PrimitiveEntity, Identifier) =&gt; PrimitiveEntity</code></pre>
<p>and for a given primitive entity <code>pe</code>, the <em>fiber/inverse-image</em> of π over <code>pe</code>, is the collection of tuples upstairs that maps to <code>pe</code> downstairs. That is the list of primitive entity identifiers corresponding to that primitive entity.</p>
<p>The new model in proto is</p>
<pre><code>message Entity {
  repeated String primitive_entity_names = 1;
}

message PrimitiveEntity { // fka EntityKeyType
  String name = 1;
}

message PrimitiveEntityIdentifier { // fka EntityKey
  String primitive_entity = 1;
  String identifier = 2;
}</code></pre>
<p>If we want an Entity to have a name, we can define a function <code>Entity =&gt; String</code> which is basically <code>Entity.primitiveEntityNames.mkString(&quot;_&quot;)</code>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This doesn’t look like much of a change, but it is actually pretty significant. We exploded the hierarchy of things each of which <em>has a</em> list of the next things on it. It is now clear what the basic things are, which things are built from other things and how, and we have much more flexibility in how we program with these new types.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
