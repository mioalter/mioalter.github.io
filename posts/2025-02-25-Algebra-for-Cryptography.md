---
title: Algebra For Cryptography I
---
\newcommand{\bb}{\mathbb}
\newcommand{\Z}{\mathbb Z}
\newcommand{\F}{\mathbb F}

My friend [Dan][Dan] texted me a question about the Advanced Encryption Standard ([AES][AES])
algorithm: he was writing a reference implementation in Haskell to check his understanding
of the implementation in—highly optimized—assembler that he was working with.
I know nothing about cryptography, but was game to look at his implementation.
Something that immediately jumped out was [an integer value named "irrPolynomial"][DanAES]
which I took to mean "irreducible polynomial." This piqued my interest.
I spent a few days taking peeks at the Handbook of Applied Cryptography—and
my grad school Abstract Algebra textbook to shake out the cobwebs—
and thought about this while I was walking the dog or doing dishes.
I then blasted Dan with an extremely long text thread explaining what
was going on mathematically and the sequence of steps that got me to that understanding.
This post is that text thread, very lightly edited.

I'll just add a couple things up front.
First, I am not an expert and I could easily have made mistakes here!
Nonetheless, I hope that seeing my reasoning is illuminating.
Second, if you are not comfortable with equivalence relations and quotient constructions,
that's okay! These are advanced undergraduate ideas that most students to not encounter
in their full generality. They are, however, totally ubiquitous in mathematics
and it is extremely worthwhile to bite the bullet and get comfortable with them.
I have a previous blog post about them, but feel free to go directly to the source:
the basic idea is covered in the eleven-and-a-half page "Preliminaries" chapter
of [Dummit and Foote][DandF]. It is worth reading.
(It covers a bunch of things, it does not use all of that space on this one idea.)
If you would like to find a copy of the book, I would definitely not search on
the internet for the title of the book and "pdf". Why waste your time?

# Why?

The point of all of this is to answer the question: what do $n$-bit binary integers
have to do with polynomials and why is relating those things to each other at all useful?
Read on to find out!

# Rings and Ideals

If $R$ is a commutative ring, a subset $I$ of $R$ is an [_ideal_][ideal] if it is

* closed under addition and multiplication
* has the "absorption" property: anything in $R$ times anything in $I$ lands back in $I$.

The ideal generated by a subset $S\subseteq R$ is the set of all sums of eleemnts of $S$
multiplied by elements of $R$.
A very nice kind of ideal is an ideal generated by a set with one element:
if $S = \{s\}$, this ideal is written simply as $(s)$.
An ideal generated by a single element is called a [_principal_ ideal][pi].

Ideals are the subsets of rings we can "mod out" by, that is, out of which we can form quotient rings:
if $I$ is an ideal, we consider elements of $R$ to be equivalent if their difference is in $I$,
then define addition and multiplication on the set $R/I$ of equivalence classes in terms
of the corresponding operations on $R$. Ideals have nice properties that make this work.

# Modular arithmetic
The integers are a ring $\Z$, the set of all multiples of $n$ is an ideal $(n)$,
and the integers mod $n$ is the quotient ring $\Z/(n)$.
We usually write this using group and subgroup notation $\Z/n\Z$ rather than ring
and ideal notation, but that is what it is.


# Fields
A [field][field] is basically a ring in which every element has an additive
inverse and every non-zero element has a multiplicative inverse.
So we can add, multiply, subtract, and divide.
Fields can be finite or infinite.
If $p$ is a prime, then $\Z/p\Z$ is a field. $\Z/p^n\Z$, however, is not a field:
in this ring, it is possible to multiply together two non-zero numbers,
e.g. $p$ and $p^{n-1}$, and get zero.
It [follows from the definition of a field][consequences] that, in a field,
this never happens. (Fields are [_integral domains_][id].)

# Questions
We can ask two related questions

1. If we have $n$-bit binary integers, sure they form a ring, but can we make them into a field?
2. If we know that $\Z/p\Z$ is a field, but that $\Z/p^n\Z$ is not, is there a way
to make more fields by, like, making $n$-tuples of field elements into a field?

These are related because we can think of $n$-bit binary integers as $n$-tuples of
binary digits, that is, of elements of the field $\Z/2\Z$.
If we want to do the first thing—make those $n$-tuples into a field—maybe there is some
general construction—a way to do the second thing—that will help us out.

The answer is: there is a way to make $n$-tuples of field elements into a field,
but in a not-at-all obvious way.

# First attempt

Let’s just write $\F$ for our field for the moment and think about what we can do
with $\F^n$, the set of n-tuples of elements of $\F$.
We can obviously add and multiply them component-wise.
We would like $(0,\ldots,0)$ to be the zero element, the additive identity,
of our field and $(1,\ldots,1)$ to the be the multiplicative identity.
The problem though is: say $n = 3$, we could have $(1,0,1)$ and $(0,1,0)$,
neither of those is $(0,0,0)$, but, if we multiply them together component-wise,
we get $(0,0,0)$.
And we know you can't do that in a field. So this won’t quite work.

We did manage to make $\F^n$ into a ring, though, just not a field.
What if we forget a little bit of structure and just consider $\F^n$ as a vector space
so we can add elements and scale them, i.e. multiply them by elements of $\F$
—$c(f_1,…,f_n) = (cf_1,…,cf_n)$ for $c$ in $\F$—but we cannot multiply two
$n$-tuples together.

Does that help?
Maybe! If there is some other way to construct this vector space and we can figure out
how to turn _that_ vector space into a field, then we can turn this thing into a field.
(This will use a standaard trick that we'll get to after we do it.)

# Second attempt

Here is another way to make $\F^n$ as a vector space:
take the ring of polymomials with coefficients in $\F$ in a single variable,
this is denoted $\F[x]$,
form the principal ideal generated by the single polynomial $x^n$,
and take the quotient by that ideal: $\F[x] / (x^n)$.
As a vector space, this has a basis $1, x, x^2, \ldots, x^{n-1}$, that is,
every polynomial in that quotient ring can be written uniquely as
$a_0 + a_1 x + … + a_{n-1}x^{n-1}$
where the $a_i$ are in $\F$.
This is just like modular arithmetic of integers: the equivalence class of every
integer mod $n$ has a unique representative between $0$ and $n-1$.

This almost works! But not quite. The problem is that $x^n$ is a reducible polynomial:
we can write it as, say, $x (x^{n-1})$ and that means that we again have nonzero
elements that we can multiply together to get $0$ :(.
So, again, this is not a field.
However, if we choose an _irreducible_ polynomial $f(x)$, one that cannot be written
as a product of lower degree polynomials, then this doesn’t happen.
And, in fact—proof / exercise—if we take the quotient of $\F[x]$ by the ideal
generated by $f(x)$, $\F[x] / (f(x))$,
that _is_ a field.
And if we forget the field structure and just think of it as a vector space,
this "_is_" the vector space $\F^n$ we started with!
More specifically: there is a function $\phi: \F^n \to \F[x]/(f(x))$,
defined by $\phi(a_0,\ldots,a_{n-1}) = a_0 + a_1 x + \ldots a_{n-1} x^{n-1}$,
from the thing we were trying to make into a field to this thing that is a field
and this function—exercise again—is a vector space isomorphism.

# Success

So, the punchline is: if we have $n$-bit binary integers
$[b_{n-1}, \ldots.b_0]$ and we want to make them into a field,
we can take the field $\Z/2\Z$—also frequently denoted $\F_2$—
find an irreducible polynomial of degree $n$,
form the field $\F_2[x] / (f(x))$, of polynomials with coeffcients in $\F_2$
(again, just the integers mod 2) by modding out by that irreducible polynomial,
and think of a $n$-bit binary integer as a polynomial
i.e. $[b_{n-1}….b_0] \leftrightarrow b_{n-1}x^{n-1} + \ldots + b_1 x + b_0$.
When we do arithmetic in that field, if we want to go back to arrays of bits,
we have to remember to choose the unique polynomial of degree $< n$ equivalent to
whatever we have before we can map back to an array of bits.
We do that by adding or subtracting $f(x)$ some number of times until we find it
or, equivalently, using the fact that $f(x)$ is equivalent to $0$ to rewrite it.

# The Standard Trick

There is a general trick that if $S$ is a set and $C$ is some cool algebraic
thing like a group, ring, vector space, field, whatever,
and we have a bijection of sets $\phi: S \to C$,
then we can make $S$ into a cool algebraic thing by “pulling back” the operations
on $C$: to perform operations on a pair, say, of elements of $S$ we just send them
over to $C$, operate there, then send the result back and define that to be how
operations on $S$ work.
So that is what is happening here: we have some operations on arrays of bits of size $n$,
but not all the ones we want. We do, however, have a bijection to this fancy
polynomial ring where multiplication is really nice—it is a field so everything
has a multiplicative inverse—so we can just define a new multiplication on arrays
of bits by sending them over there, multiplying there, and sending the answer back.


![image][sorry]


[AES]: https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
[consequences]: https://en.wikipedia.org/wiki/Field_(mathematics)#Consequences_of_the_definition
[Dan]: https://github.com/pittma
[DanAES]: https://github.com/pittma/crypto-ref/blob/0cabf4d9c62af993a598616a0e928b23b255044e/src/AES/Shared.hs#L10-L14
[DandF]: https://www.wiley.com/en-us/Abstract+Algebra%2C+3rd+Edition-p-9780471433347
[field]: https://en.wikipedia.org/wiki/Field_(mathematics)
[id]: https://en.wikipedia.org/wiki/Integral_domain
[ideal]: https://en.wikipedia.org/wiki/Ideal_(ring_theory)
[multGF]: https://github.com/pittma/crypto-ref/blob/0cabf4d9c62af993a598616a0e928b23b255044e/src/GF.hs#L17
[pi]: https://en.wikipedia.org/wiki/Principal_ideal
[sorry]: images/sorry.jpg
