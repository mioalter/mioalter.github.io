---
title: Algebra For Cryptography I
---

Rings and Ideals
If `R` is a commutative ring, a subset `I` of `R` is an ideal that
1. is closed under addition and multiplication
2. ⁠has the absorption property: for all `r in R` and `i in I`, `ri in R` so if you multiply something in `I` by anything in `R`, you land back in `I`.
The ideal generated by a set `S` is the set of all `{r_1 s_1 + … + r_n s_n | r_i in R, s_i in S}` so finite sums of things in `S` times things in `R`.
A very nice kind of ideal is an ideal generated by a set with one element: if `S = {s}`, this is usually write  simply as `(s)`. An ideal generated by a single element is called a _principal_ ideal.

Ideals are the things we can quotient a ring by and still get a ring meaning, we can define addition and multiplication on the set of equivalence classes `R/I` in terms of the operations on `R` and the properties of an ideal make that actually work.

Integers mod n:
The integers are a ring `Z`, for any `n`, the set of all multiples of `n` is a principal ideal `(n)`, and the integers mod `n` is the quotient of the ring `Z` by the ideal `(n)`. We usually write `Z/nZ` using group notation rather than `Z/(n)` using ring and ideal notation, but that is what it is.

Next: fields. A field is a ring where every element has an additive inverse and every non-zero element has a multiplicative inverse. Fields can be finite or infinite. `Z/pZ` for `p` a prime is a field. `Z/p^kZ` however is not a field: we can multiply `p` and `p^{k-1}` say which are both non-zero elements, but their product is `0` :(.
We can ask two related questions that come from different places
1. if we have n-bit binary integers, sure, they form a ring, but can we make them into a field?
2. ⁠if we know that `Z/pZ` is a field, could we make more fields by, like making n-tuples of field elements into a field?
These are related because we can think of n-bit binary integers are n-tuples of elements of `Z/2Z`, or `F_2`, the field with two elements and, if we want to make that into a field, we might want to appeal to some general construction that works for any field and any `n`.
The answer is, we can, but in a very not-obvious way.

Let’s just write `F` for our field for the moment and think about with we can do with `F^n`, the set of n-tuples of elements of `F`. We can obviously add and multiply them component-wise. We would kind of want `(0,…,0)` to be the zero element, the additive identity, of our field and `(1,…,1)` to the be the multiplicative identity. The problem though is: say n = 3, we could have `(1,0,1)` and `(0,1,0)`, neither of those is `(0,0,0)`, but, if we multiply them together component-wise, we get `(0,0,0)`.  So that won’t work. So we got as far as making a ring, but then ran into trouble. What if we forget a little bit of structure and just consider `F^n` as a vector space so we can add elements and scale them by elements of `F` e.g. `c(f_1,…,f_n) = (cf_1,…,cf_n)` for `c in F`. Does that help? Well, if we can find some other way to make this vector space, then it might.

Here is another way to make `F^n` as a vector space: take the ring of polymomials with coefficients in `F` in a single variable `F[x]`, form the principal ideal generated by the single polynomial `x^n` and take the quotient by that: `F[x] / (x^n)`. Then, as a vector space, that has a basis `1, x, x^2, …, x^{n-1}`, that is, every polynomial in that quotient ring can be written uniquely as `a_0 + a_1 x + … + a_{n-1}x^{n-1}` where the `a_i` are in `F`. This is just like modular arithmetic of integers: the equivalence class of every integer mod `n` has a unique representative between `0` and `n-1`.

This almost works!
But not quite

`x^n` is a reducible polynomial: we can write it as, say, `x * x^{n-1}` and that means that we again have nonzero elements that we can multiply together to get `0` :(. However, if we choose an _irreducible_ polynomial `f(x)`, one that cannot be written as a product of lower degree polynomials, then this doesn’t happen. An in fact—proof / exercise—if we take the quotient of `F[x]` by the ideal generated by `f(x)`, `F[x] / (f(x))`, that _is_ a field. And if we forget the field structure and just think of it as a vector space, we have a vector space isomorphism between `F[x]/(f(x))` and the thing we were trying to make into a field `F^n`.

So, the punchline is: if we have n-bit binary integers `[b_{n-1}….b_0]` and we want to make them into a field, we can take the field `F_2`, find an irreducible polynomial of degree `n`, form the field `F_2[x] / (f(x))`, of polynomials with coeffcients in `F_2` (just the integers mod 2) mod that irreducible polynomial, and think of a binary integer as a polynomial i.e. `[b_{n-1}….b_0] <-> b_{n-1}x^{n-1} + … + b_1 x + b_0`. When we do arithmetic in that field, if we want to go back to arrays of bits, we have to remember to choose the unique polynomial of degree < n equivalent to whatever we have before we can map back to an array of bits. We do that by adding or subtracting `f(x)` some number of times until we find it.

So, I did not work through the details of your `multGF`, but I am conceptually sure that that is what that has to do with: do arithemtic in this quotient ring of polynomials, then shfit the result back down to a polynomial of degree < n so that it corresponds to an array of bits.

Sorry, this is very long.

It should probably be a blogpost rather than a text thread

I guess the last thing that I’ll say that I feel like I say a lot, but I may not write down enough is: there is a general trick that if `S` is a set and `C` is some cool algebraic thing like a group, ring, vector space, field, whatever, and we have a bijection of sets `S -> C`, then we can make `S` into a cool algebraic thing by “pulling back” the operations on `C`: to perform operations on a pair, say, of elements of `S`, we just send them over to `C`, operate there, then send the result back and define that to be how operations on `S` work. So that is what is happening here: we have some operations in arrays of bits of size n, but not all the ones we want. We do, however, have a bijection to this fancy polynomial ring where multiplication is really nice—it is a field so everything has a multiplicative inverse—so we can just define a new multiplication on arrays of bits by sending them over there, multiplying there, and sending the answer back.


